#=
This is the place, where I put functions, which are so annoying in OpenGL, that I felt the need to wrap them and make them more "Julian"
Its also to do some more complex error handling, not handled by the debug callback
=#



function ModernGL.glGetShaderiv(shaderID::GLuint, variable::GLenum)
  const result = GLint[-1]
  glGetShaderiv(shaderID, variable, result)
  result[1]
end
function glShaderSource(shaderID::GLuint, shadercode::Vector{Uint8})
    shader_code_ptrs  = Ptr{Uint8}[pointer(shadercode)]
    len               = GLint[length(shadercode)]
    glShaderSource(shaderID, 1, shader_code_ptrs, len)
end
function glGetAttachedShaders(program::GLuint)
    shader_count   = glGetProgramiv(program, GL_ATTACHED_SHADERS)
    length_written = GLsizei[0]
    shaders        = zeros(GLuint, shader_count)

    glGetAttachedShaders(program, shader_count, length_written, shaders)
    shaders[1:first(length_written)]
end


get_attribute_location(program::GLuint, name::Symbol) = get_attribute_location(program, string(name))
function get_attribute_location(program::GLuint, name::ASCIIString)
   const location::GLint = glGetAttribLocation(program, name)
   if location == -1
       error("Named attribute (:$(name)) is not an active attribute in the specified program object or\n
           the name starts with the reserved prefix gl_\n")
   elseif location == GL_INVALID_OPERATION
       error("program is not a value generated by OpenGL or\n
               program is not a program object or\n
               program has not been successfully linked")
   end
   location
end

get_uniform_location(program::GLuint, name::Symbol) = get_uniform_location(program, string(name))
function get_uniform_location(program::GLuint, name::ASCIIString)
   const location::GLint = glGetUniformLocation(program, name)
   if location == -1
       error("Named uniform (:$(name)) is not an active attribute in the specified program object or\nthe name starts with the reserved prefix gl_\n")
   elseif location == GL_INVALID_OPERATION
       error("program is not a value generated by OpenGL or\n
               program is not a program object or\n
               program has not been successfully linked")
   end
   location
end

function glGetActiveUniform(programID::GLuint, index::Integer)
    const actualLength   = GLsizei[1]
    const uniformSize    = GLint[1]
    const typ            = GLenum[1]
    const maxcharsize 	 = glGetProgramiv(programID, GL_ACTIVE_UNIFORM_MAX_LENGTH)
    const name           = Array(GLchar, maxcharsize)

    glGetActiveUniform(programID, index, maxcharsize, actualLength, uniformSize, typ, name)
    if actualLength[1] > 0
    	uname = bytestring(pointer(name), actualLength[1])
    	uname = symbol(replace(uname, r"\[\d*\]", "")) # replace array brackets. This is not really a good solution.
    	(uname, typ[1], uniformSize[1])
    else
    	error("No active uniform at given index. Index: ", index)
    end
end
function glGetActiveAttrib(programID::GLuint, index::Integer)
    const actualLength   = GLsizei[1]
    const attributeSize  = GLint[1]
    const typ            = GLenum[1]
    const maxcharsize    = glGetProgramiv(programID, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH)
    const name           = Array(GLchar, maxcharsize)

    glGetActiveAttrib(programID, index, maxcharsize, actualLength, attributeSize, typ, name)
    if actualLength[1] > 0
      uname = bytestring(pointer(name), actualLength[1])
      uname = symbol(replace(uname, r"\[\d*\]", "")) # replace array brackets. This is not really a good solution.
      (uname, typ[1], attributeSize[1])
    else
      error("No active uniform at given index. Index: ", index)
    end
end
function glGetProgramiv(programID::GLuint, variable::GLenum)
    const result = GLint[-1]
    glGetProgramiv(programID, variable, result)
    result[1]
end
function glGetIntegerv(variable::GLenum)
    const result = GLint[-1]
    glGetIntegerv(Uint32(variable), result)
    result[1]
end




function glGenBuffers()
    const result = GLuint[0]
    glGenBuffers(1, result)
    id = result[1]
    if id <= 0
        error("glGenBuffers returned invalid id. OpenGL Context active?")
    end
    id
end
function glGenVertexArrays()
    const result = GLuint[0]
    glGenVertexArrays(1, result)
    id = result[1]
    if id <=0
        error("glGenVertexArrays returned invalid id. OpenGL Context active?")
    end
    id
end
function glGenTextures()
    const result = GLuint[0]
    glGenTextures(1, result)
    id = result[1]
    if id <= 0
        error("glGenTextures returned invalid id. OpenGL Context active?")
    end
    id
end
function glGenFramebuffers()
    const result = GLuint[0]
    glGenFramebuffers(1, result)
    id = result[1]
    if id <= 0
        error("glGenFramebuffers returned invalid id. OpenGL Context active?")
    end
    id
end

function glDeleteTextures(id::GLuint)
  arr = [id]
  glDeleteTextures(1, arr)
end
function glDeleteVertexArrays(id::GLuint)
  arr = [id]
  glDeleteVertexArrays(1, arr)
end
function glDeleteBuffers(id::GLuint)
  arr = [id]
  glDeleteBuffers(1, arr)
end






function glGetTexLevelParameteriv(target::GLenum, level, name::GLenum)
  result = GLint[0]
  glGetTexLevelParameteriv(target, level, name, result)
  result[1]
end

glViewport(x::Rectangle) = glViewport(x.x, x.y, x.w, x.h)

function glGenRenderbuffers(format::GLenum, attachment::GLenum, dimensions)
    renderbuffer = GLuint[0]
    glGenRenderbuffers(1, renderbuffer)
    glBindRenderbuffer(GL_RENDERBUFFER, renderbuffer[1])
    glRenderbufferStorage(GL_RENDERBUFFER, format, dimensions...)
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, attachment, GL_RENDERBUFFER, renderbuffer[1])
    renderbuffer[1]
end


function glTexImage(ttype::GLenum, level::Integer, internalFormat::GLenum, w::Integer, h::Integer, d::Integer, border::Integer, format::GLenum, datatype::GLenum, data)  

  glTexImage3D(GL_PROXY_TEXTURE_3D, level, internalFormat, w, h, d, border, format, datatype, C_NULL)
  for l in  0:level
    result = glGetTexLevelParameteriv(GL_PROXY_TEXTURE_3D, l, GL_TEXTURE_WIDTH)
    if result == 0
      error("glTexImage 3D: width too large. Width: ", w)
    end
    result = glGetTexLevelParameteriv(GL_PROXY_TEXTURE_3D, l,GL_TEXTURE_HEIGHT)
    if result == 0
      error("glTexImage 3D: height too large. height: ", h)
    end
    result = glGetTexLevelParameteriv(GL_PROXY_TEXTURE_3D, l, GL_TEXTURE_DEPTH)
    if result == 0
      error("glTexImage 3D: depth too large. Depth: ", d)
    end
    result = glGetTexLevelParameteriv(GL_PROXY_TEXTURE_3D, l, GL_TEXTURE_INTERNAL_FORMAT)
    if result == 0
      error("glTexImage 3D: internal format not valid. format: ", GLENUM(internalFormat).name)
    end
  end
  glTexImage3D(ttype, level, internalFormat, w, h, d, border, format, datatype, data)
end
function glTexImage(ttype::GLenum, level::Integer, internalFormat::GLenum, w::Integer, h::Integer, border::Integer, format::GLenum, datatype::GLenum, data)
  maxsize = glGetIntegerv(GL_MAX_TEXTURE_SIZE)
  glTexImage2D(GL_PROXY_TEXTURE_2D, level, internalFormat, w, h, border, format, datatype, C_NULL)
  for l in 0:level
    result = glGetTexLevelParameteriv(GL_PROXY_TEXTURE_2D, l, GL_TEXTURE_WIDTH)
    if result == 0
      error("glTexImage 2D: width too large. Width: ", w)
    end
    result = glGetTexLevelParameteriv(GL_PROXY_TEXTURE_2D, l, GL_TEXTURE_HEIGHT)
    if result == 0
      error("glTexImage 2D: height too large. height: ", h)
    end
    result = glGetTexLevelParameteriv(GL_PROXY_TEXTURE_2D, l, GL_TEXTURE_INTERNAL_FORMAT)
    if result == 0
      error("glTexImage 2D: internal format not valid. format: ", GLENUM(internalFormat).name)
    end
  end
  glTexImage2D(ttype, level, internalFormat, w, h, border, format, datatype, data)
end
function glTexImage(ttype::GLenum, level::Integer, internalFormat::GLenum, w::Integer, border::Integer, format::GLenum, datatype::GLenum, data)
  glTexImage1D(GL_PROXY_TEXTURE_1D, level, internalFormat, w, border, format, datatype, C_NULL)
  for l in 0:level
    result = glGetTexLevelParameteriv(GL_PROXY_TEXTURE_1D, l, GL_TEXTURE_WIDTH)
    if result == 0
      error("glTexImage 1D: width too large. Width: ", w)
    end
    result = glGetTexLevelParameteriv(GL_PROXY_TEXTURE_1D, l, GL_TEXTURE_INTERNAL_FORMAT)
    if result == 0
      error("glTexImage 1D: internal format not valid. format: ", GLENUM(internalFormat).name)
    end
  end
  glTexImage1D(ttype, level, internalFormat, w, border, format, datatype, data)
end


